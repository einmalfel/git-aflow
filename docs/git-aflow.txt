Only master is a permanent branch.
2 release-live-ranged branches:
    <rel_name>/base
    <rel_name>/devel
All the temporary branches below are prefixed with <rel_name>/ too,
which is omitted for short.

creating features:
    $ git af feature start <name> [ <dep_feature> ]
	checks that no feature of any type with same name exists in devel
	branches off from base (or <dep_feature>)
		into feature/<name> and switches to it
    do commits
    $ git af feature finish [ -dev ] <name>
	branches off from devel into testing/<name> and switches to it
	merges feature/<name> into testing/<name>
	if merge conflicts, it shows the commits and the features that
		caused the conflicts, aborts the merge and removes the
		testing/<name> branch.
		It then tries to merge the conflicting feature directly
		(fmerge) into feature/<name>.
		You should resolve the conflicts and commit the results,
		then retry with "finish" command. Alternatively, you may
		decide to abort the merge and move the conflicting
		features to base using "land" command.
	if -dev is specified, creates a lightweight tag (ltag) for
		feature/<name> named devf_<name>
	otherwise, creates an annotated tag (atag) for
		feature/<name> named feature_<name>
		you enter the detailed feature description into the tag
    you do some testing if needed
    $ git af feature commit [ <name> | -a ]
	merges testing/<name> into devel using --ff-only
	removes testing/<name>
	moves feature/<name> to backup/

landing development features:
    When enought development features accumulated, do
    $ git af base land { <name> | -a }
	branches off from base into basetest/`date` and switches to it
	merges devf_<name> (or devf_*) into basetest/`date`
    resolve merge conflicts if any, and do some testing if needed
    $ git af base commit
	merges current branch (making sure it starts with basetest/) into base
		using --ff-only
	removes basetest/*

staging features (both types):
    when feature is tested and approved, do:
    $ git af stage <name>
	branches off from master into testing/<name> and switches to it
	merges devf_<name> or feature_<name> into testing/<name>
    resolve merge conflicts if any, and do some testing if needed
    $ git af stage commit
	merges current branch (making sure it starts with testing/) into master
		using --ff-only
	removes testing/*
    Note that staged development features are still not visible by
		default to the release manager. It therefore will likely
		to go into the next major release only.

rebaseing unpuplished features:
    developer may decide to rebase feature after a base branch update.
    $ git af feature rebase <name>
	rebases feature/<name> on new base

rebaseing puplished features:
    since rebasing published branch is impossible, you should simply
    merge the new base branch to your feature branch when needed.

listing features (both types):
    $ git af list features [ -a ]
	traverses all user-visible features feature_*
	with -a lists also development features devf_*

creating hotfix for specific feature:
    $ git af hff start <name> <feature_name>
	branches off from devf_<feature_name> or feature_<feature_name>
		into hff/devf_<feature_name>/<name>
		or hff/feature_<feature_name>/<name>
		and switches to it
    do commits
    $ git af hff finish <name>
	creates an atag named hff_devf_<feature_name>_<name> or
		hff_feature_<feature_name>_<name>
	you type a hotfix description
	merges current branch into every branch that has the feature branch
		merged into
	removes current hotfix branch

creating hotfix for specific releases:
    $ git af hfr start <name> [ <min_rel_name> ]
	branches off from <min_rel_name> into hfr/<min_rel_name>/<name>
		and switches to it
    do commits
    $ git af hfr finish <name> [ <max_rel_name> ]
	creates an atag named hfr_<name>
	you type a hotfix description
	merges current hotfix branch into every release branch
	    from <min_rel_name>..<max_rel_name> range.
	    The range can include master and devel. devel is considered
	    newer than master in this case.
	    <min_rel_name> is defaulted to master if omited
	    <max_rel_name> is defaulted to devel if omited
	removes current hotfix branch
    if the problem is present in branch base, you should use
    $ git af base hfland <name>
	merges hfr_<name> into base

creating hotfix release:
    $ git checkout <existing_rel_branch>
    just tar up the release branch that contains all needed hotfixes

creating minor release:
    $ git checkout <existing_rel_branch>
    $ git af release fmerge <feature1> ...
	checks the presence of the fiature in master
	checks all of its dependencies to be either in master or base
	merges specified user-visible features
		(with their hotfixes) to current branch
    do testing and hotfixes
    tar up the release

creating major release:
    $ git af release start <rel_name>
	makes sure no unfinished release exists
	branches off from base into reltest/<rel_name> and switches to it
	merges master into current branch
    revert some features that you don't need with "frevert" command
    do release hardening commits and testing
    $ git af release finish
	branches into release/<rel_name>
	branches into <rel_name>/base
	branches into <rel_name>/devel
	switches into release/<rel_name>
	removes reltest/<rel_name>

reverting features:
    $ git af frevert <name>
	reverts feature_<name> from the current branch, if it was merged

rebasing to new release:
    after a new major release was created, the developers should
    sooner or later rebase their work to the new base and devel branches.
    $ git af rebase [ <from_name> ]
	checks if the base and devel branches exist for the latest
	    release branch, and creates them from master, if needed
	    (non-tracking)
	rebases all the (unfinished) feature branches
	    into the resp branches of the last major release
	rebases all the features from local backup/* that are present
	    in old devel branch, but are not present in the new
	    devel branch. The backup/ prefix is removed in the process.
	removes backup/*
	you need to start from "feature finish" again after that.

pushing work to remote:
    $ git af push
	checks if master branch is tracking, and if not -
	    sets up tracking for it (happens after repo creation)
	checks if any non-tracking release branches exist, and sets
	    tracking for them (happens after new release)
	checks if the latest devel and base branch are tracking, and if not -
	    sets up tracking for them (happens after a rebase to new release)
	pushes all tracking branches that has unpushed local commits
	if there were push rejects, pulls from the remote (with merges),
	    switches to the pulled branch and prints an error message
    if there were pull merges, you resolve the conflicts and do the testing,
	after wchich, retry the command.

publishing specific features:
    if you want your new feature to be worked on collaboratively,
    you may decide to publish it before completion.
    $ git af feature publish <name>
	sets up remote tracking for the feature branch feature/<name>
    $ git af push
	will push your feature branch to remote

merging features:
    this is mainly for the use by another tools. Not to be used directly.
    $ git af fmerge <name>
	merges feature_<name> into the current branch
